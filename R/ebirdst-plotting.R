#' Plot predictor importances as barplots
#'
#' For all of the available predictors in a single set of species eBird
#' Status and Trends products, this function makes a bar plot of those relative
#' importances, from highest to lowest. Many function parameters allow for
#' customized plots.
#'
#' @param path character; full path to single species eBird Status and Trends
#'   products.
#' @param pis data.frame; predictory importance data rom [load_pis()].
#' @param st_extent list; `st_extent` list for spatiotemporal filtering.
#'   Required, as results are less meaningful over large spatiotemporal extents.
#' @param by_cover_class logical; whether to aggregate FRAGSTATS metrics for the
#'   land cover classes into single values for the land cover classes.
#' @param num_top_preds integer; how many predictors to show.
#' @param return_top logical; wether to returns a vector of the top predictors,
#'   based on the `num_top_preds` param.
#' @param pretty_names logical; whether to convert cryptic land cover codes to
#'   readable land cover class names.
#' @param print_plot logical; whether to print plot, to allow only the return
#'   the top predictors, if desired.
#'
#' @return Plots barplot and/or returns a vector of top predictors.
#'
#' @export
#'
#' @examples
#' \dontrun{
#'
#' # download and load example data
#' dl_path <- tempdir()
#' sp_path <- download_data("example_data", path = dl_path)
#' pis <- load_pis(sp_path)
#'
#' # define a spatioremporal extent
#' ne_extent <- list(type = "rectangle",
#'                   lat.min = 40,
#'                   lat.max = 47,
#'                   lon.min = -80,
#'                   lon.max = -70,
#'                   t.min = 0.425,
#'                   t.max = 0.475)
#'
#' plot_pis(path = sp_path, pis = pis, st_extent = ne_extent)
#'
#' }
plot_pis <- function(path,
                     pis,
                     st_extent,
                     by_cover_class = FALSE,
                     num_top_preds = 50,
                     return_top = FALSE,
                     pretty_names = TRUE,
                     print_plot = TRUE) {
  stopifnot(dir.exists(path))
  e <- load_config(path)

  if(num_top_preds < 2) {
    stop("num_top_preds must be greater than 1.")
  }

  if(print_plot == FALSE & return_top == FALSE) {
    stop("Both print and return params are FALSE. Nothing to do!")
  }

  if(!all(is.na(st_extent))) {
    if(!is.list(st_extent)) {
      stop("The st_extent argument must be a list object.")
    }
  }

  if(is.null(st_extent$t.min) | is.null(st_extent$t.max)) {
    stop("Must provide t.min and t.max as part of st_extent for this function.")
  }


  # subset for extent
  ttt_sub <- data_st_subset(pis, st_extent)
  ttt <- ttt_sub[, e$PI_VARS]
  rm(ttt_sub)

  # if aggregating by cover class
  # aggregate the fragstats into land cover classes
  if(by_cover_class == TRUE) {
    land.cover.class.codes <- c(1:10, 12, 13, 16)
    lc.tag <- "UMD_FS_C"

    water.cover.class.codes <- c(0, 2, 3, 5, 6, 7)
    wc.tag <- "MODISWATER_FS_C"

    predictor.names <- names(ttt)

    ttt.new <- NULL
    for (iii.pred in 1:length(land.cover.class.codes)) {
      new.pred.name <- paste(lc.tag,
                             land.cover.class.codes[iii.pred],
                             "_",
                             sep = "")
      pred.nindex <- grep(new.pred.name, x = predictor.names)

      if(length(pred.nindex) == 1) {
        ttt.new <- cbind(ttt.new, ttt[, pred.nindex])
      } else {
        ttt.new <- cbind(ttt.new, apply(ttt[, pred.nindex], 1, mean, na.rm=T))
      }

      ttt.new <- as.data.frame(ttt.new)
      names(ttt.new)[ncol(ttt.new)] <- paste(lc.tag,
                                             land.cover.class.codes[iii.pred],
                                             sep="")
    }
    for (iii.pred in 1:length(water.cover.class.codes)) {
      new.pred.name <- paste(wc.tag,
                             water.cover.class.codes[iii.pred],
                             "_",
                             sep = "")
      pred.nindex <- grep(new.pred.name, x = predictor.names)

      if(length(pred.nindex) == 1) {
        ttt.new <- cbind(ttt.new, ttt[, pred.nindex])
      } else {
        ttt.new <- cbind(ttt.new, apply(ttt[, pred.nindex], 1, mean, na.rm=T))
      }

      ttt.new <- as.data.frame(ttt.new)
      names(ttt.new)[ncol(ttt.new)] <- paste(wc.tag,
                                             water.cover.class.codes[iii.pred],
                                             sep = "")
    }

    ttt <- ttt.new
    rm(ttt.new)
  }

  # replace names with readable
  if(pretty_names == TRUE) {
    names(ttt) <- convert_classes(names(ttt),
                                  by_cover_class = by_cover_class,
                                  pretty = by_cover_class)
  }

  # compute median
  pi_median <- apply(ttt, 2, stats::median, na.rm = T)

  # find the top preds based on function variable num_top_preds
  top_names <- names(pi_median)[order(pi_median,
                                      decreasing = T)][1:round(num_top_preds)]
  rm(pi_median)
  top_names <- stats::na.omit(top_names)

  # subset all values based on top_names
  top_pis <- ttt[, top_names]

  # munging and filtering for ggplot
  pi_stack <- utils::stack(top_pis)
  rm(top_pis)

  # PIs have have spurious large values, NAs and NaNs
  # so clean up, trim, and check for complete cases
  pi_stack$values[!is.numeric(pi_stack$values)] <- NA
  pi_stack <- pi_stack[pi_stack$values < stats::quantile(pi_stack$values,
                                                         probs = c(0.98),
                                                         na.rm = TRUE), ]
  pi_stack <- pi_stack[stats::complete.cases(pi_stack), ]

  # plot
  if(print_plot == TRUE) {
    pi_bars <- ggplot2::ggplot(pi_stack,
                               ggplot2::aes(stats::reorder(pi_stack$ind,
                                                           pi_stack$values,
                                                           FUN = stats::median),
                                            pi_stack$values)) +
      ggplot2::geom_boxplot() +
      ggplot2::coord_flip() +
      ggplot2::labs(y = "Relative PI", x = "") +
      ggplot2::theme_light()
    print(pi_bars)
  }

  if(return_top == TRUE) {
    return(top_names)
  }
}

#' Plot partial dependency as line plot
#'
#' For all of the available predictors in a single species set of eBird Status
#' and Trends products, this function makes a line plot of a single partial
#' dependency, with two options for smoothing.
#'
#' @param pd_name character; Single predictor name from PDs (via `load_pds()`).
#' Unique predictors can be listed by calling `pds <- load_pds(path)` and
#' then calling `unique(pds$V4)`.
#' @param pds data.frame; From `load_pds()`.
#' @param st_extent list; st_extent list for spatiotemporal filtering. Required,
#' as results are less meaningful over large spatiotemporal extents.
#' @param plot_quantiles logical; Default is FALSE. Adds a band for the
#' upper (90th) and lower (10th) quantiles of the individual stixel PD values.
#' @param pointwise_pi logical; Default is TRUE. A pointwise smoothing of
#' individual stixel PD values. Ideal visualization of the PD values.
#' @param stixel_pds logical; Default is FALSE. Toggle to plot the individual
#' stixel PD values as semi-transparent lines.
#' @param k.cont.res int; Default is 25. Number of knots to use in GAM based on
#' continuining resolution of the current eBird Status and Trends products.
#' @param gbm.n.trees int; Default is 500. Number of trees to use in pointwise
#' GAM.
#' @param nnn.bs int; Default is 100.
#' @param equivalent.ensemble.ss int; Default is 10.
#' @param ci.alpha numeric; Default is 0.05. Alpha transparency of confidence
#' intervals.
#' @param mean.all.data logical; Default is FALSE.
#' @param ylim vector pair; Opportunity to pre-define plot y-min and y-max as
#' vector pair (e.g., c(-1, 1)).
#' @param print_plot logical; Default is TRUE. Set to FALSE to turn off plotting and
#' only get return of pointwise pi values.

#'
#' @return Plots barplot and returns a list containing the quantiles
#' (if plot_quantiles = TRUE) and/or the pointwise_pis upper, lower, and
#' median (if pointwise_pi = TRUE).
#'
#' @export
#'
#' @examples
#' \dontrun{
#'
#' # download and load example data
#' dl_path <- tempdir()
#' sp_path <- download_data("example_data", path = dl_path)
#' pds <- load_pds(sp_path)
#'
#' # define a spatioremporal extent
#' ne_extent <- list(type = "rectangle",
#'                   lat.min = 40,
#'                   lat.max = 47,
#'                   lon.min = -80,
#'                   lon.max = -70,
#'                   t.min = 0.425,
#'                   t.max = 0.475)
#'
#' plot_pds(pd_name = "TIME", pds = pds, st_extent = ne_extent)
#'
#' }
plot_pds <- function(pd_name,
                     pds,
                     st_extent,
                     plot_quantiles = FALSE,
                     pointwise_pi = TRUE,
                     stixel_pds = FALSE,
                     k.cont.res = 25,
                     gbm.n.trees = 500,
                     nnn.bs = 100,
                     equivalent.ensemble.ss = 10,
                     ci.alpha = 0.05,
                     mean.all.data = FALSE,
                     ylim = NA,
                     print_plot = TRUE) {

  if(!(pd_name %in% unique(pds$V4))) {
    stop("Predictor name not in PDs.")
  }

  if(plot_quantiles == FALSE & pointwise_pi == FALSE & stixel_pds == FALSE) {
    stop(paste("Nothing to plot! Change one of the following to TRUE: ",
               "plot_quantiles, pointwise_pi, or stixel_pds.", sep = ""))
  }

  if(!all(is.na(st_extent))) {
    if(!is.list(st_extent)) {
      stop("The st_extent argument must be a list object.")
    }
  }

  if(is.null(st_extent$t.min) | is.null(st_extent$t.max)) {
    stop("Must provide t.min and t.max as part of st_extent for this function.")
  }

  # static variables
  PD_MAX_RESOLUTION <- 50
  t.ul <- NULL
  t.ll <- NULL
  t.median <- NULL
  # Defines extent of PD predictions along independent axis
  # X.tail.level of data are trimmed the both ends where data are sparser.
  # This avoids edge effects.
  x.tail.level  <- 0.0
  # Confidence level for replicate/stixel level prediction Intervals
  # Because of the relatively small sample sizes I am using 80% PIs
  gbm.tail.prob <- 0.10  # Tail probabilty [0, 0.49]
  # Number of CV folds for data driven selection of gbm's n.trees
  # parameter. Since this doesn't work on my machine I have
  # take the simpler approach of fixing the n.trees == 200
  # This seems to work well.
  gbm.cv.folds <- 0  # >= 5 computational vs statistical efficiecy
  best.iter <- gbm.n.trees
  # Number of bootstrap replicasted for Conditional Mean
  #nnn.bs <- 25
  # Number of evaluation points on x-axis / indepent var
  nd.pred.size <- PD_MAX_RESOLUTION

  return_list <- list()

  # subset based on extent
  pd_vec <- data_st_subset(pds, st_extent)

  rm(pds)

  # Select PD Variable
  var_pd <- pd_vec[pd_vec$V4 == pd_name, ]
  rm(pd_vec)
  # Clean
  var_pd <- var_pd[!is.na(var_pd$V5), ]

  pd_name <- convert_classes(pd_name, pretty = TRUE)

  # Each Column is one replicate estimate of PD
  # 	x = x coordinate values
  # 	y = y coordinate values
  pd.x <- matrix(NA, PD_MAX_RESOLUTION, nrow(var_pd))
  pd.y <- matrix(NA, PD_MAX_RESOLUTION, nrow(var_pd))
  pd.mean <- rep(NA, nrow(var_pd))

  for (rid in 1:nrow(var_pd)) {
    #rid <- 100
    pd.x[, rid] <- as.numeric(
      var_pd[rid, (PD_MAX_RESOLUTION+4):(2*PD_MAX_RESOLUTION+3)])
    ttt <- as.numeric(var_pd[rid, 3:(PD_MAX_RESOLUTION+2)])
    pd.mean[rid] <- mean(ttt, na.rm=T)
    pd.y[, rid] <- ttt - pd.mean[rid]
  }

  pd.x <- as.data.frame(pd.x)
  pd.y <- as.data.frame(pd.y)
  rm(var_pd)

  # Compute Prediction Design for 1D PD
  ttt <- data.frame(x = utils::stack(pd.x)[,1],
                    y = utils::stack(pd.y)[,1])
  nd <- data.frame(x = seq(from = stats::quantile(ttt$x,
                                                  probs = x.tail.level,
                                                  na.rm = T),
                           to = stats::quantile(ttt$x,
                                                probs = 1 - x.tail.level,
                                                na.rm = T),
                           length = nd.pred.size))

  # PLOT STIXEL PD Replicates or just set up plot
  if(print_plot == TRUE) {
      if(stixel_pds) {
        if(all(is.na(ylim))) {
          ylim <- c(min(pd.y, na.rm = TRUE), max(pd.y, na.rm = TRUE))
        }

        graphics::matplot(jitter(as.matrix(pd.x), amount = 0.00),
                          pd.y,
                          ylim = ylim,
                          xlab = '',
                          ylab = "Deviation E(Logit Occurrence)",
                          type= "l",
                          lwd = 5,
                          lty = 1,
                          col = scales::alpha("black", .025))
      }
  }

  # -----------------
  # GBM Quantiles
  # -----------------
  if(plot_quantiles) {
    ttt <- data.frame(x = utils::stack(pd.x)[,1],
                      y = utils::stack(pd.y)[,1])

    ttt <- stats::na.omit(ttt)

    d.ul <- gbm::gbm(y ~ x,
                     data = ttt,
                     distribution = list(name = "quantile",
                                         alpha = (1 - gbm.tail.prob)),
                     n.trees = gbm.n.trees,
                     interaction.depth = 4,
                     shrinkage = 0.05,
                     bag.fraction = 0.5,
                     train.fraction = 1.0,
                     cv.folds = gbm.cv.folds,
                     verbose = FALSE,
                     n.cores = 1)

    d.ll <- gbm::gbm(y ~ x,
                     data = ttt,
                     distribution = list(name = "quantile",
                                         alpha = gbm.tail.prob),
                     n.trees = gbm.n.trees,
                     interaction.depth = 4,
                     shrinkage = 0.05,
                     bag.fraction = 0.5,
                     train.fraction = 1.0,
                     cv.folds = gbm.cv.folds,
                     verbose = FALSE,
                     n.cores = 1)

    t.ul <- stats::predict(d.ul, newdata = nd, n.trees = best.iter)
    t.ll <- stats::predict(d.ll, newdata = nd, n.trees = best.iter)
    rm(d.ul, d.ll)

    poly.x <- c(nd[, 1], rev(nd[, 1]))
    poly.y <- c(t.ll, rev(t.ul))

    if(print_plot == TRUE) {

      if(stixel_pds == FALSE) {
        qymin <- min(t.ll, na.rm = TRUE)
        qymax <- max(t.ul, na.rm = TRUE)

        if(all(is.na(ylim))) {
          ylim <- c(qymin, qymax)
        }

        plot(pd.x[,1],
             pd.y[,1],
             xlab = '',
             xlim = c(min(nd, na.rm = TRUE), max(nd, na.rm = TRUE)),
             ylim = ylim,
             ylab = "Deviation E(Logit Occurrence)",
             type = "n")
      }


      graphics::polygon(poly.x,
                        poly.y,
                        col = scales::alpha("red", 0.25),
                        border = FALSE)
    }

    quantiles <- list(t.ul = t.ul, t.ll = t.ll)
    return_list$quantiles <- quantiles
  }

  # -----------------
  # GAM Pointwise CI for conditional mean estimate
  # via bootstrapping
  # -----------------
  if(pointwise_pi) {
    bs.gam.pred <- matrix(NA, nd.pred.size, nnn.bs)

    for (iii.bs in 1:nnn.bs) {
      # Take Random Sample of evaluation points
      # to account for randomness in X
      # and reduces computational time.
      # E.g. We could do this taking random
      # sample of replicates and evalution points,
      # (randomly drawing from rows and columns)
      # and set the GAM sample size at 500,
      # or the equivalent sample size when averaging
      # 10 replicate PD's each evaluated at 50 x-values.
      #
      # This suggests a nice interpretation;
      # these CI's represent the sampling variation
      # of an ensemble estimate based on a given number
      # of STIXEL PD replicates.
      #
      # equivalent.ensemble.ss <- 10
      #
      # Note that the SAME set of rows is used for every
      # column! This should be changed!
      # ------
      # Sample of STIXEL replicates
      # bs.index <- sample.int(
      # 	n = nrow(var_pd),
      # 	size = round(nrow(var_pd)*0.5),
      # 	replace = T)
      # replicate.ss <- ceiling(
      # 	equivalent.ensemble.ss*PD_MAX_RESOLUTION/length(bs.index))
      # row.index <- sample.int(
      # 	n = PD_MAX_RESOLUTION,
      # 	size = replicate.ss,
      # 	# This sets a constant fraction of available
      # 	#round(PD_MAX_RESOLUTION*0.25),
      # 	replace = F)

      rbprob <- equivalent.ensemble.ss * PD_MAX_RESOLUTION/nrow(pd.x)/ncol(pd.x)
      random.index <-  matrix((stats::rbinom(n = nrow(pd.x) * ncol(pd.x),
                                             size = 1,
                                             prob = rbprob) == 1),
                              nrow(pd.x),
                              ncol(pd.x))

      ttt <- data.frame(x = pd.x[random.index],
                        y = pd.y[random.index])

      s = mgcv::s
      d.gam <- mgcv::gam(y ~ s(x, k = k.cont.res, bs="ds", m=1),
                         data = ttt,
                         gamma = 1.5)

      bs.gam.pred[, iii.bs] <- stats::predict(d.gam, newdata = nd, se = FALSE)
      rm(d.gam)
    }

    t.ul <- apply(bs.gam.pred,
                  1,
                  stats::quantile,
                  probs = 1 - ci.alpha,
                  na.rm = TRUE)
    t.ll <- apply(bs.gam.pred,
                  1,
                  stats::quantile,
                  probs = ci.alpha,
                  na.rm = TRUE)
    t.median <- apply(bs.gam.pred,
                      1,
                      stats::quantile,
                      probs = 0.5,
                      na.rm = TRUE)

    poly.x <- c(nd[, 1], rev(nd[, 1]))
    poly.y <- c(t.ll, rev(t.ul))
    if(print_plot == TRUE) {

      if(stixel_pds == FALSE & plot_quantiles == FALSE) {
        qymin <- min(t.ll, na.rm = TRUE)
        qymax <- max(t.ul, na.rm = TRUE)

        if(all(is.na(ylim))) {
          ylim <- c(qymin, qymax)
        }

        plot(pd.x[,1],
             pd.y[,1],
             xlab = '',
             xlim = c(min(nd, na.rm = TRUE), max(nd, na.rm = TRUE)),
             ylim = ylim,
             ylab = "Deviation E(Logit Occurrence)",
             type = "n")
      }


      graphics::polygon(poly.x,
                        poly.y,
                        col = scales::alpha("blue", 0.25),
                        border = FALSE)
      graphics::lines(nd[, 1],
                      t.median,
                      col = scales::alpha("darkorange", 1.0),
                      lwd = 2 * graphics::par()$cex)
    }

    pointwise <- list(t.median = t.median, t.ul = t.ul, t.ll = t.ll)
    return_list$pointwise <- pointwise
  }

  # GAM CONDITIONAL MEAN - ALL DATA
  if(mean.all.data) {
    ttt <- data.frame(x = utils::stack(pd.x)[, 1],
                      y = utils::stack(pd.y)[, 1])

    d.gam <- mgcv::gam(y ~ s(x, k = k.cont.res, bs="ds", m=1),
                       data = ttt,
                       gamma = 1.5)

    p.gam <- stats::predict(d.gam, newdata = nd, se = TRUE)
    rm(d.gam)

    if(print_plot == TRUE) {
      graphics::polygon(x = c(nd[, 1], rev(nd[, 1])),
                        y = c(p.gam$fit + 2 * p.gam$se.fit,
                              rev(p.gam$fit - 2 * p.gam$se.fit)),
                        col = scales::alpha("lightblue", 0.25),
                        border = NA)
      graphics::lines(nd[, 1],
                      p.gam$fit,
                      col = scales::alpha("yellow", 0.75),
                      lwd = 2 * graphics::par()$cex)
    }
  }

  if(print_plot == TRUE) {
    graphics::title(pd_name, line = -2)
    graphics::abline(0, 0, col="black", lwd = 3 * graphics::par()$cex)
  }


  return(return_list)
}

#' Converts cryptic cover class names to readable land cover names
#'
#' Internal function that converts the cryptic predictor class names to
#' readable land cover names.
#'
#' @param cov_names character; vector of cover class names to convert.
#' @param by_cover_class logical; whether to replace FRAGSTATS cover class name
#'   with a name for the cover class as whole.
#' @param pretty logical; whether to convert from capital case to title case.
#'
#' @return A vector of converted names.
#'
#' @keywords internal
#'
#' @examples
#' cns <- c("UMD_FS_C1_1500_PLAND", "MODISWATER_FS_C7_1500_LPI")
#' converted <- ebirdst:::convert_classes(cov_names = cns, pretty = TRUE)
convert_classes <- function(cov_names,
                            by_cover_class = FALSE,
                            pretty = FALSE) {

  if(by_cover_class == TRUE) {
    ending <- ""
  } else {
    ending <- "_"
  }

  # subset to cover classes
  land.cover.class.codes <- c(1:10, 12, 13, 16)
  lc.tag <- "UMD_FS_C"
  land_covers <- paste(lc.tag, land.cover.class.codes, ending, sep = "")

  water.cover.class.codes <- c(0, 2, 3, 5, 6, 7)
  wc.tag <- "MODISWATER_FS_C"
  water_covers <- paste(wc.tag, water.cover.class.codes, ending, sep = "")

  both_covers <- c(land_covers, water_covers)

  land_cover_names <- c("EVERGREEN_NEEDLELEAF_FOREST",
                        "EVERGREEN_BROADLEAF_FOREST",
                        "DECIDUOUS_NEEDLELEAF_FOREST",
                        "DECIDUOUS_BROADLEAF_FOREST",
                        "MIXED_FOREST",
                        "CLOSED_SHRUBLANDS",
                        "OPEN_SHRUBLANDS",
                        "WOODY_SAVANNAS",
                        "SAVANNAS",
                        "GRASSLANDS",
                        "CROPLANDS",
                        "URBAN",
                        "BARREN")

  water_cover_names <- c("SHALLOW_OCEAN", "OCEAN_COASTLINES_AND_LAKE_SHORES",
                         "SHALLOW_INLAND_WATER", "DEEP_INLAND_WATER",
                         "MODERATE_OCEAN", "DEEP_OCEAN")

  both_names <- paste(c(land_cover_names, water_cover_names), ending, sep = "")

  converted <- c()
  for(n in cov_names) {
    a <- both_covers[which(!is.na(pmatch(both_covers, n)))]
    b <- both_names[which(!is.na(pmatch(both_covers, n)))]

    conv <- ifelse(length(a) > 0, stringr::str_replace_all(n, a, b), n)
    converted <- c(converted, conv)
  }

  if(pretty == TRUE) {
    converted <- lettercase::str_title_case(
      lettercase::str_lower_case(converted))
  }

  return(converted)
}
